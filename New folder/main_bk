/*
Name :
				Khiem Lam
				Benjamin Esqueda
				Harkaran Cheema
				Jun Hou Chen
  */


#include "main.h" /* include peripheral declarations */
#include "MKL25Z4.h"
#include "adc16.h"
#include "timers.h"
#define PW1_const 4500
#define TPM1_MOD 60000
#define TPM0_MOD 600
volatile unsigned short PW1 = 4500, PW2 = 200,PW3=300;
unsigned short PW1L=3250,PW1R=5500;
int turnL=0, turnR=0;


//unsigned short MOD1=6000, MOD0=600;

volatile char TPMflag = 0;
volatile unsigned short counter_LED;
volatile int Dec,Inc,redBlink;

unsigned char ADC_Array0[128];// Ping buffer used to store ADC values
unsigned char ADC_Array1[128]; //Pong buffer
unsigned char ADC_Array2[128]; //Sing buffer
unsigned char ADC_Array3[128]; //Song buffer

unsigned char trackBuffer[127];
unsigned char MSB, LSB;

 
int counterP,counterS;
int doneP;
int doneS;
int doneBoth;
int ping,sing;
int pingTurn;
int idxP,idxS;        // Index used to implement circular buffer
int counterGPIO;
int read3, read7, printLast2=0;
unsigned char A_IFB,B_IFB;
unsigned short current=PW1_const;
int servoInit=1;

const uint32_t led_mask[] = { 1UL << 18, 1UL << 19, 1UL << 1 };
#define LED_RED    0
#define LED_GREEN  1
#define LED_BLUE   2
 

void init_ADC0(void);

unsigned char findAvg(unsigned char Arr[128]){
 
    int i, x = 0;
    for (i = 0; i<128; i++)
        x = x + Arr[i];
    x = x / 128;
    return x;
 
}
 
unsigned char findDiff(unsigned char Arr[128], unsigned char *getMin){
    int min, max, i;
    min = Arr[0];
    max = min;
    for (i = 1; i<128; i++){
        if (min>Arr[i]) min = Arr[i];
        if (max< Arr[i]) max = Arr[i];
    }
		*getMin=min;
    return (max - min);
}
 
unsigned char findNeutralPos(unsigned char buffer[128]){
  unsigned char Vol_threshold;

	unsigned char  base,diff;
	
	diff=findDiff(buffer,&base);
	Vol_threshold=diff/2 + base;
	
	return Vol_threshold;
}
void algorithmFirst(unsigned char buffer[128]){
	unsigned char Vol_threshold;
	int i;
	unsigned char  base,diff;
	unsigned int tmpAvg=0;

	diff=findDiff(buffer,&base);
	Vol_threshold=diff/2 + base;
	
	for (i=0;i<128;i++)
	{
		if(buffer[i]<Vol_threshold)  {
			uart0_putchar('0');//pArr[i]=0; //black pixel
		
		}
		else {
			uart0_putchar('1');//pArr[i]=1; //white pixel
		
			
		}
		
	}
	
	uart0_putchar(' ');
	
}

/*
void algorithmFirst(unsigned char buffer[128], int *count1, int *count0){
	unsigned char Vol_threshold;
	int i;
	unsigned char  base,diff;
	unsigned int tmpAvg=0;
	*count1=0;
	*count0=0;
	diff=findDiff(buffer,&base);
	Vol_threshold=diff/2 + base;
	
	for (i=0;i<128;i++)
	{
		if(buffer[i]<Vol_threshold)  {
			uart0_putchar('0');//pArr[i]=0; //black pixel
			*count0+=1;
		}
		else {
			uart0_putchar('1');//pArr[i]=1; //white pixel
			*count1+=1;
			
		}
		
	}
	
	uart0_putchar(' ');
	
}
*/
unsigned char findRatio(unsigned char ADC_Arr[128]){
	unsigned char Vthreshold;
	int i;
	unsigned char count0=0, count1=0;
	Vthreshold=findNeutralPos(ADC_Arr);
	for(i=0;i<128;i++){
		if (ADC_Arr[i] < Vthreshold) count0++;
		else count1++;
	}
	return count1/count0;
}
/*
void LED_Initialize(void) {
 
    SIM->SCGC5 |= (SIM_SCGC5_PORTB_MASK
        | SIM_SCGC5_PORTD_MASK | SIM_SCGC5_PORTE_MASK);                 // Enable Clock to Port B & D 
    PORTB->PCR[18] = (1UL << 8);                      // Pin PTB18 is GPIO 
    PORTB->PCR[19] = (1UL << 8);                      // Pin PTB19 is GPIO 
    
 
 
    FPTB->PDOR = (led_mask[0] | led_mask[1]);          // switch Red/Green LED off  
    FPTB->PDDR = (led_mask[0] | led_mask[1]);          //enable PTB18/19 as Output 
		
	
    FPTD->PDOR = led_mask[2];            // switch Blue LED off  
    
	}
    
   
 */

void Init_ADC(void) {
	
	init_ADC0();			// initialize and calibrate ADC0
	ADC0->CFG1 = (ADLPC_LOW | ADIV_1 | ADLSMP_LONG | MODE_8 | ADICLK_BUS_2);	// 8 bit, Bus clock/2 = 12 MHz
	ADC0->SC2 = 0;		// ADTRG=0 (software trigger mode)
	ADC0->CFG2 = ADC_CFG2_MUXSEL_MASK;
}


unsigned int Read_ADC (void) {
	volatile unsigned int res=0;
	
	ADC0->SC1[0] = 0xC; 			// start conversion (software trigger) on AD12 i.e. ADC0_SE12 (PTB2)
	
	while (!(ADC0->SC1[0] & ADC_SC1_COCO_MASK)) {	; }		// wait for conversion to complete (polling)

	res = ADC0->R[0];				// read result register
	return res;
}

void TPM0_IRQHandler(void) {
	
	NVIC_ClearPendingIRQ(TPM0_IRQn);
	
	if(TPM0->CONTROLS[0].CnSC & TPM_CnSC_CHF_MASK)
		TPM0->CONTROLS[0].CnSC |= TPM_CnSC_CHF_MASK;
	if(TPM0->CONTROLS[2].CnSC & TPM_CnSC_CHF_MASK)
		TPM0->CONTROLS[2].CnSC |= TPM_CnSC_CHF_MASK;
	
	TPM0->CONTROLS[0].CnV =PW2;
	TPM0->CONTROLS[2].CnV =PW3;
}
void TPM1_IRQHandler(void) {
//clear pending IRQ
	NVIC_ClearPendingIRQ(TPM1_IRQn);
	
	
// clear the Channel flag mask by writing 1 to CHF
		
	if (TPM1->CONTROLS[0].CnSC & TPM_CnSC_CHF_MASK) 
		TPM1->CONTROLS[0].CnSC |= TPM_CnSC_CHF_MASK;
	

TPM1->CONTROLS[0].CnV = PW1;
}

void Init_PWM(void) {

// Set up the clock source for MCGPLLCLK/2. 
// See p. 124 and 195-196 of the KL25 Sub-Family Reference Manual, Rev. 3, Sept 2012
// TPM clock will be 48.0 MHz if CLOCK_SETUP is 1 in system_MKL25Z4.c.
	
	SIM-> SOPT2 |= (SIM_SOPT2_TPMSRC(1) | SIM_SOPT2_PLLFLLSEL_MASK | SIM_SOPT2_UART0SRC(1));
	
	
// See p. 207 of the KL25 Sub-Family Reference Manual, Rev. 3, Sept 2012
	
	SIM->SCGC6 |= SIM_SCGC6_TPM1_MASK; // Turn on clock to TPM1 (servo)
	SIM->SCGC6 |= SIM_SCGC6_TPM0_MASK; // Turn on clock to TPM0
	
	SIM->SCGC5 |= (SIM_SCGC5_PORTA_MASK
								| SIM_SCGC5_PORTB_MASK
								| SIM_SCGC5_PORTC_MASK
								| SIM_SCGC5_PORTD_MASK
								| SIM_SCGC5_PORTE_MASK );
	
	
	
	PORTA->PCR[1] = PORT_PCR_MUX(0x2);		// Enable the UART0_RX function on PTA1
	PORTA->PCR[2] = PORT_PCR_MUX(0x2);		// Enable the UART0_TX function on PTA2


		PORTD->PCR[7] = (1UL << 8);    /* Pin PTD7  is GPIO */
    PORTE->PCR[1] = 1UL << 8;              //Pin PTE1 is GPIO
		PORTB->PCR[0] = (1UL << 8);   // Pin PTB0 is GPIO
    FPTD->PDDR |= 1UL << 7; //PTD7 as an output
    FPTE->PDDR |= 1UL << 1; //PTE1 as an output
		FPTD->PDDR |= 1UL << 1;          /* enable PTD1 as Output */                                            
		FPTB->PDOR |= 1;                                                                 // initialize PTB0
    FPTB->PDDR |= 1;                                                                 // configure PTB0 as output

	
	PORTE->PCR[21] = 1UL << 8; //PTE21 is an GPIO /EN pin
	PORTC->PCR[13] = PORT_PCR_MUX(1); //PORT PTC13 is an GPIO pin (SW1)
	PORTC->PCR[17] = PORT_PCR_MUX(1); //PORT PTC17 is an GPIO  pin (SW2)
	//PORTC->PCR[2] = PORT_PCR_MUX(1); //configure PTC2 as GPIO
//	PORTC->PCR[4] = PORT_PCR_MUX(1); //configure PTC4 as GPIO
PORTC->PCR[2] = 1UL<<8;
PORTC->PCR[4] = 1UL<<8;
	
	FPTC->PDDR = 1UL << 2 | 1UL << 4 ; //set PTC2 and PTC4 as an output GPIO
	FPTC->PDDR &=~(1UL<<13 | 1UL<<17) ; // assign 0 to PTC13(SW1) and PTC17(SW2) to set them as an input GPIO
	
	FPTE->PDDR |= 1UL << 21 ; // PTE21 is configured as an output
	FPTE->PCOR = 1UL << 21; //turn PTE21(EN) off /DISABLE H-Bridge
	//PTC->PDOR = 1UL<<2 | 1UL<<4;
	FPTC->PCOR =1UL<<2; // deassert PTC2
	FPTC->PCOR = 1UL<<4 ; // deassert PTC4
	
	
// See p. 163 and p. 183-184 of the KL25 Sub-Family Reference Manual, Rev. 3, Sept 2012
	
	PORTB->PCR[0] = PORT_PCR_MUX(3); // Configure PTB1 as TPM1_CH1 (servo)
	PORTC->PCR[1] = PORT_PCR_MUX(4); //configure PTC1 as TPM0_CH0
	PORTC->PCR[3] = PORT_PCR_MUX(4); //configure PTC3 as TPM0_CH2
	
	
// Set channel TPM1_CH0 to edge-ligned, high-true PWM
	
 	TPM1->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;//(servo)
		TPM1->CONTROLS[0].CnSC |=  TPM_CnSC_CHIE_MASK; //(for servo)
		
		// Set channel TPM0_CH1/TPC1 to center-ligned, high-true PWM
		TPM0->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK |TPM_CnSC_CHIE_MASK ;

		
		// Set channel TPM0_CH2/TPC3 to center-aligned, high-true PWM
		TPM0->CONTROLS[2].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK |TPM_CnSC_CHIE_MASK ;
	
		// Set channel PTC3/TPM0_CH2 to center-aligned, low-true PWM
	//	TPM0->CONTROLS[2].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSA_MASK ;
		
// Set period and pulse widths for TPM1
	
	TPM1->CONTROLS[0].CnV = PW1_const; 	//(for servo)
	TPM1->MOD = TPM1_MOD-1;	//5khz	// Freq. = (48 MHz / 16) / 3000 = 1k Hz
	
	// Set period and pulse widths for TPM0 CH1 / LEFT - POT1
	TPM0->MOD = TPM0_MOD-1;	//5khz	// Freq. = (48 MHz / 16) / 3000 =  1k Hz
	TPM0->CONTROLS[0].CnV = PW2;
	

	
	// Set period and pulse widths for TPM0 CH2 / RIGHT - POT2
	TPM0->CONTROLS[2].CnV = PW3;
	
	
// set TPM1 to up-counter, divide by 16 prescaler and clock mode
	TPM1->SC = ( TPM_SC_CMOD(1) | TPM_SC_PS(4));
	
	// set TPM0 to up/down-counter, divide by 16 prescaler and clock mode
	//TPM0->SC = (TPM_SC_CPWMS_MASK | TPM_SC_PS(4));
	TPM0->SC = ( TPM_SC_CMOD(1) | TPM_SC_PS(4));

// clear the Channel flag mask by writing 1 to CHF
	if (TPM1->CONTROLS[0].CnSC & TPM_CnSC_CHF_MASK) TPM1->CONTROLS[0].CnSC |= TPM_CnSC_CHF_MASK;
	
	// clear the Channel flag mask on CH1 by writing 1 to CHF
	//if (TPM0->CONTROLS[0].CnSC & TPM_CnSC_CHF_MASK) TPM0->CONTROLS[0].CnSC |= TPM_CnSC_CHF_MASK;//
	if (TPM0->CONTROLS[0].CnSC & TPM_CnSC_CHF_MASK) TPM0->CONTROLS[0].CnSC |= TPM_CnSC_CHF_MASK;
	
	// clear the Channel flag mask on CH2 by writing 1 to CHF
	
		if (TPM0->CONTROLS[2].CnSC & TPM_CnSC_CHF_MASK) TPM0->CONTROLS[2].CnSC |= TPM_CnSC_CHF_MASK;

// Enable Interrupts

	NVIC_SetPriority(TPM0_IRQn, 192); // 0, 64, 128 or 192
	NVIC_ClearPendingIRQ(TPM0_IRQn); 
	NVIC_EnableIRQ(TPM0_IRQn);	
	
	NVIC_SetPriority(TPM1_IRQn, 128); // 0, 64, 128 or 192
	NVIC_ClearPendingIRQ(TPM1_IRQn); 
	NVIC_EnableIRQ(TPM1_IRQn);	

	
	
	//counter_LED=0;
	//redBlink=0;

}	


void put(char *ptr_str)
{
	while(*ptr_str)
		uart0_putchar(*ptr_str++);
}

unsigned char hex_ascii(unsigned char hex){
    unsigned char ascii;
    if (hex>9) ascii = hex - 10 + 'A';
    else ascii = hex + '0';
 
    return ascii;
}
void print(unsigned char hex, int b){
	if(b) hex=hex_ascii((hex>>4) & 0x0f);
	else hex=hex_ascii(hex&0x0f);
	uart0_putchar(hex);
}


void printBuff(unsigned char *ADC_Arr){
	int i;
	for(i=0; i<128;i++){
		print(ADC_Arr[i],1);
		print(ADC_Arr[i],0);
		uart0_putchar(' ');
	}
}

int main(void){
	char check;
	int uart0_clk_khz;
	char str[] = "\r\nExit! \r\n";
	char str1[] = "\r\nPlease turn power supply on, then press SW2! \r\n";
	char str2[] = "\r\nFeedback signals from A_IFB and B_IFB ";
	char str3[] = "\r\n";
	unsigned int ret;
	int flag=1;
	int neutralR,neutralL;
	unsigned char pot1,pot2;
	unsigned char baseP;
	int j;
	unsigned char centralPosR= 0x55;//36(hex)
	unsigned char centralPosL =0x41 ;//26(hex)
	unsigned char rangeMin=0x20;
	unsigned char rangeMax=0x24;
	unsigned char rangeLeft=0x2C;
	unsigned char rangeRight=0x26 ;
	
	int ratio;
	int count1P,count1S;
  int count0P,count0S;
	int diff;
	
	// Lab 4 variables
	
		char strSing[] = "\r\nPing and Sing Buffer \r\n";
		char strSong[] = "\r\nPong and Song Buffer \r\n";
   
    int cq_present; 
	
		int pingFlg, singFlg;
    ping = 1;
		sing =1;
		pingTurn=1; //ping buffer start first

	 Init_PWM();  
	 uart0_clk_khz = (48000000 / 1000); // UART0 clock frequency will equal half the PLL frequency	
	uart0_init (uart0_clk_khz, TERMINAL_BAUD);  

	
// LED_Initialize();
    
    Init_ADC();
    Init_PIT(10000);        // count-down period = 10,000 us
    Start_PIT();
 
    // Enable Interrupts 
    NVIC_SetPriority(ADC0_IRQn, 128); // 0, 64, 128 or 192
    NVIC_ClearPendingIRQ(ADC0_IRQn);
    NVIC_EnableIRQ(ADC0_IRQn);

	neutralR=1;
	neutralL=1;	
	
	
	put(str1);
		while(!( FPTC->PDIR & 1UL<<17)){}
		
		FPTE->PSOR = 1UL << 21; //enable H-Bridge
	
			//PART 2
			
			while(flag){
					ADC0->SC1[0] = 0xD; 			// start conversion (software trigger) on AD13 i.e. ADC0_SE13 (PTB3)
						while (!(ADC0->SC1[0] & ADC_SC1_COCO_MASK)) {	; }		// wait for conversion to complete (polling)
						pot1 = ADC0->R[0]; //POT1 left 
							print(pot1,1);
							print(pot1,0);
							uart0_putchar(' ');
						
					ADC0->SC1[0] = 0xC; 			// start conversion (software trigger) on AD13 i.e. ADC0_SE13 (PTB3)
							while (!(ADC0->SC1[0] & ADC_SC1_COCO_MASK)) {	; }		// wait for conversion to complete (polling)
								pot2 = ADC0->R[0]; //POT2 right
								print(pot2,1);
								print(pot2,0);
								uart0_putchar(' ');
						
					
							if(FPTC->PDIR & 1UL<<13) {
								PW2 = pot1*2 + pot1/3;
								PW3 = pot2*2 + pot2/3 ;
								flag=0;
							}
				}
			
				
				while (1) {
  
            						
  if(uart0_getchar_present()== 0){
		
		
			//the outer most camera is ping/right camera
					if(doneP){
						if (ping)  {
							algorithmFirst(ADC_Array0);
							pingFlg=1;
							//algorithmFirst(ADC_Array0, &count1P, &count0P);
							
							//ratio=(count0P*10)/count1P;
							
						/*	diff=count0P-count1P;
							if (diff<=rangeMax && diff>=rangeMin) PW1=PW1_const;
							else if((diff>rangeMax) && (diff<=rangeRight)) PW1 = PW1L;
							else if((diff>rangeRight) && (diff<=rangeLeft))
								PW1=PW1R;
							*/
						
						}
						else {
							algorithmFirst(ADC_Array1);
							pingFlg=0;
							/*
							algorithmFirst(ADC_Array1, &count1P, &count0P);
						//	ratio=(count0P*10)/count1P;					
							
							diff=count0P-count1P;
						if (diff<=rangeMax && diff>=rangeMin) PW1=PW1_const;
							else if((diff>rangeMax) && (diff<=rangeRight)) PW1 = PW1L;
							else if((diff>rangeRight) && (diff<=rangeLeft))
								PW1=PW1R;
								*/
						
								
										 
						}
						/*
						//	put(str3);
						put("\n\rcount1 : ");
							
							print(count1P,1);
							print(count1P,0);
							uart0_putchar(' ');	
						
						put("count0 : ");
						uart0_putchar(' ');	
							print(count0P,1);
							print(count0P,0);
							uart0_putchar(' ');	
							put("difference : ");
						
							print(diff,1);
							print(diff,0);
							put("\n\r");
								*/
						if (ping) ping = 0;
										else ping = 1;
							doneP = 0;	
						//	put("\n\r");						
					}
					if(doneS){
						
						if(sing){
						algorithmFirst(ADC_Array2);
							singFlg=1;
							//count1S=algorithmFirst(ADC_Array2);
							/*
							algorithmFirst(ADC_Array2, &count1S, &count0S);
							ratio=(count0S*10)/count1S;
							diff=count0S-count1S;
						
							singFlg=1;
							put("\n\r");
							//put(strSing);
							*/
						}
						else {
						algorithmFirst(ADC_Array3);
							singFlg=0;
							/*
							//count1S=algorithmFirst(ADC_Array3);
							algorithmFirst(ADC_Array2, &count1S, &count0S);
							ratio=(count0S*10)/count1S;
							diff=count0S-count1S;
						
							singFlg=0;
							//put("\n\r");
						//	put(strSong);
							*/
						}
						
								
							
						
							
						
						/*
							put("\n\rcount1S : ");
							
							print(count1S,1);
							print(count1S,0);
							uart0_putchar(' ');	
						
						put("count0S : ");
						uart0_putchar(' ');	
							print(count0S,1);
							print(count0S,0);
							uart0_putchar(' ');	
							put("ratio : ");
						
							print(diff,1);
							print(diff,0);
							put("\n\r");
							*/
							if(sing) sing=0;
									else sing=1;
						doneS=0;
						put("\n\r");
					}
				}
	
		else{
									 check = uart0_getchar();
										if(check == 'p'){
												//Turn off PIT
										 NVIC_DisableIRQ(PIT_IRQn);
											
	
									/*		
											if(printLast2){
											put(str2);
												print(A_IFB,1);
												print(A_IFB,0);
												uart0_putchar(' ');
											
												print(B_IFB,1);
												print(B_IFB,0);
												uart0_putchar(' ');
												put(str3);
											}		
											*/
											
											 // print buffer contents
												if (!pingTurn){
													if (pingFlg) printBuff(ADC_Array0);
													else printBuff(ADC_Array1);
												}
												else {
													if(singFlg) printBuff(ADC_Array2);
													else printBuff(ADC_Array3);
												}
				 
							
																do{
																		cq_present = 0;
																		 
																 
																				check=uart0_getchar();
		
																	
																	
																				if (check == 'c'){
																						
																						NVIC_EnableIRQ(PIT_IRQn);
																						cq_present = 1;
																				}
				 
																				else if (check == 'q'){
																						put(str);
																						NVIC_DisableIRQ(PIT_IRQn); // PIT interrupt
																						NVIC_DisableIRQ(ADC0_IRQn); // conversion interrupt
																						NVIC_DisableIRQ(TPM1_IRQn); //Servo interrupt
																						NVIC_DisableIRQ(TPM0_IRQn); // motor interrupt
																						FPTE->PCOR = 1UL<<21; 			// DISABLE H-Bridge
																						
																				
																						cq_present = 1;
																						return 0;
																				}

														}while(!cq_present);
														
													
														 
								} // end check=='p'
						} // end else
		
	
					
					
	} // end of while			
} // end main
 

void ADC0_IRQHandler() {
	NVIC_ClearPendingIRQ(ADC0_IRQn);	
		FPTE->PSOR = 1UL<<1; //assert PTE1 /CLK
	
 // ADC0->CFG2 |= ADC_CFG2_MUXSEL_MASK; //select b channel  
	
    // read one value from ADC0 using software triggering
	
	if(pingTurn){
		
			 counterP++;
			 
				if (ping)
            ADC_Array0[idxP] = ADC0->R[0];     //Read to Ping buffer	
				else 
						ADC_Array1[idxP] = ADC0->R[0];    //Read to Pong buffer  
						
				        
				if(idxP==127) {
					doneP=1;
					doneS=0;
				}
			
		
				if (counterS<129)					
					ADC0->SC1[0] = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(7); // start conversion on C2
				
				
		
				pingTurn=0; //turn Sing on
				idxP++;       
		
	}
 else {
	 
				
				counterS++;
		
				if (sing )
						ADC_Array2[idxS]=ADC0->R[0]; //read data from Result reg, assign it to Sing buffer
				else 
						ADC_Array3[idxS]=ADC0->R[0]; // REad data from result reg and assign it to Song buffer
				
				if (idxS==127){ 
					doneS=1;
					doneP=0;
				}
					
				
			
				if (counterP<129)
					ADC0->SC1[0]=AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(6);  //start conversion on C1		
			
				pingTurn=1; //turn Ping on
				idxS++;       
			
			}
				
		//	if (doneS && doneP) doneBoth=1;
	/*		
   	counterGPIO++;
			
			if(read7){
				read7=0;
				A_IFB = ADC0->R[0];
				ADC0->CFG2 = ADC_CFG2_MUXSEL_MASK;
				printLast2=1;
			}
			if(read3){
				read3=0;
				B_IFB = ADC0->R[0];		
				ADC0->CFG2 = 0;
				ADC0->SC1[0] = AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(7);
				read7=1;
			
			}
			if(counterGPIO==256){
				FPTB->PCOR = (1UL << 0); //deassert PTB0, start conversion    
				
				//NVIC_ClearPendingIRQ(ADC0_IRQn);
				ADC0->CFG2 = 0; //select a channel for conversion	
				//ADC0->SC1[0]=0x3;
				ADC0->SC1[0]=AIEN_ON | DIFF_SINGLE | ADC_SC1_ADCH(3);
				read3=1;
			}
			
				*/
			
	
			
			FPTE->PCOR = 1UL<<1; // deassert PTE1/ CLK
        
}

				
	/*	
			//PART 1
			
		put(str1);
		while(!( FPTC->PDIR & 1UL<<17)){}
		
		FPTE->PSOR = 1UL << 21; //enable H-Bridge
		
			put(str2);
			while(flag){
					ADC0->SC1[0] = 0xD; 			// start conversion (software trigger) on AD13 i.e. ADC0_SE13 (PTB3)
						while (!(ADC0->SC1[0] & ADC_SC1_COCO_MASK)) {	; }		// wait for conversion to complete (polling)
						ret = ADC0->R[0]; //POT1 left 
							print(ret,1);
							print(ret,0);
						PW2 = ret*2+ret/3;
						
					ADC0->SC1[0] = 0xC; 			// start conversion (software trigger) on AD13 i.e. ADC0_SE13 (PTB3)
							while (!(ADC0->SC1[0] & ADC_SC1_COCO_MASK)) {	; }		// wait for conversion to complete (polling)
								ret = ADC0->R[0]; //POT2 right
								print(ret,1);
								print(ret,0);
							PW3 = ret*2+ret/3;
							
						//	NVIC_DisableIRQ(TPM0_IRQn);
							
						//	NVIC_EnableIRQ(TPM0_IRQn);
							
							if(FPTC->PDIR & 1UL<<13) {
								flag=0;
								NVIC_DisableIRQ(TPM0_IRQn); // turn off the motor
								
								
							}
			}
	}	


*/

/*
key = uart0_getchar();
		uart0_putchar(key);
	switch(key){
				case 'C' : PW1=4500;
									
					break;
				case 'c' : PW1=4500;
		
					break;
				case 'L' : PW1=6000;
										redBlink=1;
					break;
				case 'l' : PW1=5250;
		
					break;
				case 'R' : PW1=3000;
										redBlink=1;
					break;
				case 'r' : PW1=3750;
		
					break;
				case '+' : PW1++;
					break;
				case '-' : PW1--;
					break;
				case 'Q' : put(str);
									return 0;
					break;
				case 'q' : put(str);
									return 0;
				
			}
		
*/


